# Тема 1.1. Управление процессами и службами

## Объем
2 часа

## Введение

Управление процессами и службами является одной из ключевых задач системного администратора. В многопользовательской операционной системе, такой как ОС «Альт», одновременно могут выполняться сотни процессов, и важно уметь эффективно управлять ими для обеспечения стабильной работы системы. Неправильное управление процессами может привести к перегрузке системы, конфликтам ресурсов или отказу в обслуживании.

В этой лекции мы рассмотрим основы процессов в Linux, научимся управлять ими с помощью командной строки, изучим систему инициализации systemd, которая используется в современных дистрибутивах, включая ОС «Альт». Также разберем управление службами, мониторинг системы и чтение системных журналов. Особое внимание уделим практическим навыкам, которые понадобятся для повседневной административной работы.

**Цели лекции:**
- Понимать архитектуру процессов в Linux
- Уметь управлять процессами и сигналами
- Владеть инструментами мониторинга системы
- Научиться работать с systemd и systemctl
- Уметь читать и анализировать системные журналы
- Научиться настраивать автоматическое выполнение задач

**Задачи лекции:**
1. Изучить типы и состояния процессов
2. Освоить команды управления процессами
3. Понять архитектуру systemd
4. Научиться управлять службами
5. Освоить методы диагностики проблем
6. Научиться работать с планировщиками задач

К концу лекции вы сможете уверенно управлять процессами и службами, диагностировать проблемы и настраивать автоматическое выполнение задач.

## Понимание роли процессов

Процесс — это запущенная программа, выполняющаяся в оперативной памяти. В Linux каждый процесс имеет уникальный идентификатор (PID) и может порождать другие процессы (дочерние). Процессы являются основой многозадачности системы.

### Типы процессов

**Системные процессы:**
- Запускаются при загрузке системы
- Обеспечивают работу ядра и системных служб
- Имеют низкие PID (обычно от 1)
- Примеры: init, systemd, kswapd0

**Пользовательские процессы:**
- Запускаются пользователями
- Выполняют прикладные задачи
- Имеют PID от 1000 и выше
- Примеры: firefox, bash, python

**Фоновые процессы (демоны):**
- Работают без прямого взаимодействия с пользователем
- Обслуживают сетевые запросы, печать, cron и т.д.
- Обычно заканчиваются на 'd' (sshd, httpd, crond)

### Иерархия процессов

Каждый процесс имеет:
- **PID (Process ID):** Уникальный числовой идентификатор
- **PPID (Parent Process ID):** Идентификатор родительского процесса
- **UID/GID:** Пользователя и группы, от имени которых работает процесс

Процесс init (PID 1) — главный процесс системы, от которого "рождаются" все остальные.

**Таблица: Сравнение типов процессов**
| Тип процесса | PID диапазон | Примеры | Назначение |
|-------------|--------------|---------|------------|
| Системные | 1-999 | init, systemd, kswapd0 | Работа ядра и системных служб |
| Пользовательские | 1000+ | firefox, bash, python | Прикладные задачи |
| Демоны | Любые | sshd, httpd, crond | Фоновые службы |

**Схема иерархии процессов:**
```
init (PID 1)
├── systemd (PID 2)
│   ├── sshd (PID 100)
│   ├── httpd (PID 101)
│   └── crond (PID 102)
└── bash (PID 200, пользователь ivan)
    ├── firefox (PID 201)
    └── python (PID 202)
```

## Характеристики состояния процесса

Процессы в Linux могут находиться в различных состояниях, что важно для диагностики и управления.

### Основные состояния процессов

**R (Running/Runnable):**
- Процесс выполняется или готов к выполнению
- Ожидает только процессорного времени

**S (Sleeping):**
- Процесс ожидает события (ввод/вывод, сигнал)
- Может быть прерван сигналом

**D (Uninterruptible Sleep):**
- Процесс ожидает ввод/вывод
- Не может быть прерван сигналом
- Опасное состояние — может "зависнуть"

**T (Stopped):**
- Процесс остановлен сигналом (например, Ctrl+Z)
- Может быть возобновлен

**Z (Zombie):**
- Процесс завершился, но родитель не считал статус
- Занимает запись в таблице процессов
- Проблема, если таких много

**Таблица: Сравнение состояний процессов**
| Состояние | Символ | Описание | Может быть прерван? | Особенности |
|----------|--------|----------|-------------------|-------------|
| Running | R | Выполняется или готов | Да | Нормальное состояние |
| Sleeping | S | Ожидает события | Да | Самое распространенное |
| Uninterruptible | D | Ожидает ввод/вывод | Нет | Опасное состояние |
| Stopped | T | Остановлен сигналом | Да | Может быть возобновлен |
| Zombie | Z | Завершился, но не "похоронен" | Нет | Требует вмешательства |

**Схема переходов состояний процесса:**
```
[New] → [Running] ↔ [Sleeping] → [Zombie] → [Dead]
     ↓         ↓         ↓
   [Stopped] ←───────┘
     ↓
   [Running] (после CONT)
```

### Приоритеты и nice-значения

Каждый процесс имеет приоритет планировщика:
- **PRI (Priority):** Текущий приоритет (обычно 20-39)
- **NI (Nice):** Смещение приоритета (-20 до +19)
- Чем меньше nice, тем выше приоритет

Стандартный nice = 0, PRI = 20.

## Управление процессами

Эффективное управление процессами — основа администрирования. Рассмотрим ключевые команды и методы.

### Просмотр процессов

**ps (Process Status):**
```bash
ps aux          # Полный список всех процессов
ps -ef          # Альтернативный формат
ps -u username  # Процессы пользователя
ps -p PID       # Информация о конкретном процессе
```

**top и htop:**
```bash
top             # Интерактивный монитор процессов
htop            # Улучшенная версия top (если установлена)
```

**Пример вывода ps aux:**
```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  21992  3280 ?        Ss   10:00   0:00 /sbin/init
ivan      1234  1.2  2.5 512345 51234 ?        Ssl  10:05   0:10 /usr/bin/firefox
```

### Запуск процессов

**Фоновые процессы:**
```bash
command &       # Запуск в фоне
nohup command & # Запуск, не зависящий от терминала
```

**Приоритеты:**
```bash
nice -n 10 command    # Запуск с nice=10
renice 5 PID          # Изменение nice существующего процесса
```

### Управление процессами

**Сигналы:**
```bash
kill PID          # Отправка SIGTERM (15) — мягкое завершение
kill -9 PID       # Отправка SIGKILL (9) — жесткое завершение
kill -STOP PID    # Остановка процесса
kill -CONT PID    # Возобновление процесса
```

**Группы процессов:**
```bash
pkill -f pattern  # Завершение по имени
killall name      # Завершение всех процессов с именем
```

**Примеры:**
```bash
# Завершить все процессы firefox
pkill firefox

# Завершить процесс по полному имени
killall firefox

# Отправить SIGTERM процессу с PID 1234
kill 1234

# Отправить SIGKILL (если SIGTERM не сработал)
kill -9 1234
```

## Система инициализации

Система инициализации управляет процессом загрузки и запуском служб. В современных Linux-системах, включая ОС «Альт», используется systemd.

### Что такое systemd

systemd — это система инициализации и менеджер служб, заменивший традиционный SysV init. Он обеспечивает:
- Параллельный запуск служб
- Зависимости между службами
- Контроль за процессами
- Логирование через journald

### Архитектура systemd

**Основные компоненты:**
- **systemd:** Главный процесс (PID 1)
- **systemctl:** Утилита управления
- **systemd-journald:** Системный журнал
- **systemd-tmpfiles:** Управление временными файлами

**Unit-файлы:**
systemd использует unit-файлы для описания ресурсов:
- `.service` — служба
- `.socket` — сокет
- `.timer` — таймер
- `.target` — цель (аналог runlevel)

**Таблица: Сравнение systemd и SysV init**
| Характеристика | SysV init | systemd |
|---------------|-----------|---------|
| Запуск служб | Последовательный | Параллельный |
| Зависимости | Скрипты | Декларативные unit-файлы |
| Логирование | Разрозненные файлы | Централизованный журнал |
| Управление | init.d скрипты | systemctl |
| Процессы | Не отслеживаются | Контроль за всеми процессами |

### Цепочки запуска

systemd загружается сразу после ядра и:
1. Монтирует файловые системы
2. Запускает основные службы
3. Загружает пользовательские службы
4. Передает управление сеансом пользователя

**Схема загрузки systemd:**
```
Ядро Linux
    ↓
systemd (PID 1)
    ↓
systemd-journald (логирование)
    ↓
systemd-udevd (устройства)
    ↓
systemd-networkd (сеть)
    ↓
Пользовательские службы
    ↓
Сеанс пользователя
```

## Управление службами

Службы (сервисы) — это фоновые процессы, обеспечивающие работу системы. Управление ими — важнейшая задача администратора.

### Команды systemctl

**Базовые операции:**
```bash
systemctl start name.service    # Запуск службы
systemctl stop name.service     # Остановка службы
systemctl restart name.service  # Перезапуск службы
systemctl reload name.service   # Перезагрузка конфигурации
systemctl status name.service   # Просмотр статуса
```

**Автозагрузка:**
```bash
systemctl enable name.service   # Включение автозагрузки
systemctl disable name.service  # Отключение автозагрузки
systemctl is-enabled name.service # Проверка автозагрузки
```

**Просмотр служб:**
```bash
systemctl list-units            # Список активных unit'ов
systemctl list-unit-files       # Список всех unit'ов
systemctl --failed              # Список упавших служб
```

### Примеры управления службами

**Работа с SSH-сервером:**
```bash
# Проверить статус SSH
systemctl status sshd

# Запустить SSH
systemctl start sshd

# Включить автозагрузку SSH
systemctl enable sshd

# Остановить SSH
systemctl stop sshd
```

**Работа с веб-сервером:**
```bash
# Проверить, установлен ли Apache
systemctl list-unit-files | grep httpd

# Запустить и включить
sudo systemctl start httpd
sudo systemctl enable httpd
```

### Unit-файлы

Unit-файлы находятся в:
- `/usr/lib/systemd/system/` — системные
- `/etc/systemd/system/` — пользовательские (имеют приоритет)

**Пример unit-файла:**
```ini
[Unit]
Description=My Custom Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/myservice
Restart=always
User=myuser

[Install]
WantedBy=multi-user.target
```

## Мониторинг и диагностика системы

Эффективный мониторинг позволяет оперативно выявлять и устранять проблемы.

### Инструменты мониторинга

**systemctl status:**
```bash
systemctl status sshd
# Показывает: активен/неактивен, PID, время работы, последние логи
```

**journalctl:**
```bash
journalctl -u sshd              # Логи службы sshd
journalctl -f                   # Просмотр в реальном времени
journalctl --since "1 hour ago" # Логи за последний час
journalctl -p err               # Только ошибки
```

**htop:**
```bash
htop  # Интерактивный монитор с цветовой индикацией
```

### Диагностика проблем

**Частые проблемы:**
1. Служба не запускается
2. Высокая нагрузка на CPU
3. Нехватка памяти
4. Зависшие процессы

**Пошаговая диагностика:**
```bash
# 1. Проверить статус службы
systemctl status servicename

# 2. Посмотреть логи
journalctl -u servicename -n 50

# 3. Проверить ресурсы
top
free -h

# 4. Проверить зависимости
systemctl list-dependencies servicename
```

**Типичные сценарии диагностики:**

**Сценарий 1: Служба не запускается**
```bash
# Проверяем статус
systemctl status apache2

# Читаем логи
journalctl -u apache2 -n 20

# Проверяем конфигурацию
apache2ctl configtest

# Проверяем порты
netstat -tlnp | grep :80
```

**Сценарий 2: Высокая нагрузка на CPU**
```bash
# Смотрим процессы по CPU
top -o %CPU

# Конкретный процесс
ps -p PID -o %cpu,%mem,cmd

# Анализ системы
iostat 1 5
vmstat 1 5
```

**Сценарий 3: Нехватка памяти**
```bash
# Проверяем память
free -h
cat /proc/meminfo

# Процессы по памяти
ps aux --sort=-%mem | head -10

# Своп
swapon --show
```

**Сценарий 4: Зависший процесс**
```bash
# Находим зависший процесс
ps aux | grep -E "(D|T).*process_name"

# Проверяем, можно ли убить
kill -0 PID && echo "Процесс жив" || echo "Процесс мертв"

# Если D-состояние - только перезагрузка поможет
```

**⚠️ Важно:** При диагностике всегда начинайте с простого и постепенно усложняйте анализ.

### Мониторинг ресурсов

**CPU:**
```bash
top -p PID          # Мониторинг конкретного процесса
ps -p PID -o %cpu   # CPU для процесса
```

**Память:**
```bash
free -h             # Общая память
ps -p PID -o %mem   # Память процесса
smem -t             # Подробная статистика памяти
```

**Диск:**
```bash
df -h               # Занятость дисков
iostat              # Нагрузка на диски
```

## Чтение системных журналов

Системные журналы — основной источник информации о работе системы.

### Форматы логов

**systemd-journald:**
- Централизованное логирование
- Бинарный формат
- Автоматическое управление размером

**Традиционные логи:**
- `/var/log/messages` — общие сообщения
- `/var/log/auth.log` — аутентификация
- `/var/log/syslog` — системные события

### Команда journalctl

**Базовые команды:**
```bash
journalctl                    # Все логи
journalctl -n 100             # Последние 100 записей
journalctl -f                 # Режим "хвоста" (tail -f)
journalctl --since "10 min ago" # За последние 10 минут
```

**Фильтрация:**
```bash
journalctl -u sshd            # По службе
journalctl _PID=1234          # По PID
journalctl -p err             # По уровню важности
journalctl --identifier=kernel # По идентификатору
```

**Уровни важности:**
- 0: emerg (аварийный)
- 1: alert (тревога)
- 2: crit (критический)
- 3: err (ошибка)
- 4: warning (предупреждение)
- 5: notice (замечание)
- 6: info (информация)
- 7: debug (отладка)

### Практические примеры

**Поиск проблем с загрузкой:**
```bash
journalctl -b                 # Логи текущей загрузки
journalctl -b -1              # Логи предыдущей загрузки
```

**Анализ производительности:**
```bash
# Поиск медленных служб
systemd-analyze blame

# Анализ времени загрузки
systemd-analyze
```

## Планировщик задач

Автоматизация рутинных задач — важная часть администрирования.

### Cron и crontab

**Постоянные задачи:**
```bash
crontab -e          # Редактирование пользовательских задач
crontab -l          # Просмотр задач
crontab -r          # Удаление всех задач
```

**Формат crontab:**
```
* * * * * command
│ │ │ │ │
│ │ │ │ └── День недели (0-7, где 0 и 7 — воскресенье)
│ │ │ └──── Месяц (1-12)
│ │ └────── День месяца (1-31)
│ └──────── Час (0-23)
└────────── Минута (0-59)
```

**Примеры:**
```bash
# Каждый день в 2:00 утра
0 2 * * * /backup/script.sh

# Каждые 15 минут
*/15 * * * * /check/process.sh

# По будням в 9:00
0 9 * * 1-5 /work/start.sh
```

### at и batch

**Единоразовые задачи:**
```bash
at 14:30          # Задача на 14:30 сегодня
at now + 1 hour   # Через час
at 10:00 tomorrow # Завтра в 10:00
batch             # Задача при низкой нагрузке
```

**Пример:**
```bash
echo "/backup/full.sh" | at 02:00
```

### systemd timers

**Современная альтернатива cron:**
```bash
systemctl list-timers           # Список таймеров
systemctl start name.timer      # Запуск таймера
systemctl enable name.timer     # Включение автозагрузки
```

**Пример unit-файла таймера:**
```ini
# mytimer.timer
[Unit]
Description=Run myscript every hour
Requires=myscript.service

[Timer]
OnCalendar=hourly
Persistent=true

[Install]
WantedBy=timers.target
```

### Практические рекомендации

**Выбор инструмента:**
- **cron:** Для регулярных задач (ежедневно, еженедельно)
- **at:** Для единоразовых задач
- **systemd timers:** Для сложных расписаний и интеграции с systemd

**Безопасность:**
- Ограничивайте доступ к crontab
- Проверяйте права на скрипты
- Логируйте выполнение задач

## Заключение

Управление процессами и службами — фундаментальный навык системного администратора. Владение командами ps, top, systemctl, journalctl позволяет эффективно управлять системой, диагностировать проблемы и поддерживать стабильную работу.

**Ключевые моменты:**
- Понимание типов и состояний процессов
- Умение управлять процессами и сигналами
- Навыки работы с systemd и systemctl
- Умение читать и анализировать системные журналы
- Настройка автоматического выполнения задач

**Лучшие практики:**
- Всегда начинайте диагностику с простых команд
- Используйте `journalctl` для анализа проблем со службами
- Регулярно мониторьте ресурсы системы
- Настройте автоматическое выполнение рутинных задач
- Документируйте изменения в конфигурации

**Связь с лабораторными работами:**
- Лабораторное занятие №6: Работа с процессами и службами
- Лабораторное занятие №7: Настройка сетевых параметров и межсетевого экрана
- Лабораторное занятие №8: Настройка удаленного доступа по протоколу SSH

Эти навыки будут активно использоваться при настройке серверов, диагностике проблем и автоматизации административных задач.

**Чек-лист для самопроверки:**
- [ ] Могу определить тип и состояние процесса
- [ ] Умею управлять процессами с помощью kill, pkill, killall
- [ ] Владею командами ps, top, htop для мониторинга
- [ ] Понимаю архитектуру systemd
- [ ] Умею управлять службами через systemctl
- [ ] Могу читать и анализировать системные журналы
- [ ] Настроил задачи в cron и systemd timers
- [ ] Могу диагностировать типичные проблемы с процессами и службами

## Вопросы для самоконтроля

1. Что такое процесс и чем он отличается от программы?
2. Какие существуют состояния процессов и чем они отличаются?
3. Как просмотреть все запущенные процессы в системе?
4. В чем разница между сигналами SIGTERM и SIGKILL?
5. Что такое nice-значение и как оно влияет на приоритет процесса?
6. Что такое systemd и чем он отличается от SysV init?
7. Какие типы unit-файлов существуют в systemd?
8. Как включить автозагрузку службы?
9. Как посмотреть логи конкретной службы?
10. В чем разница между cron, at и systemd timers?
11. Как диагностировать проблему с зависшим процессом?
12. Как настроить задачу для выполнения каждый день в 3 часа ночи?
13. Что такое PID и PPID?
14. Как остановить все процессы по имени?
15. Как проверить, запущена ли служба?

## Практические задания

**Задание 1: Исследование процессов**
1. Запустите команду `ps aux` и найдите процессы с состоянием S и R
2. Используя `top`, найдите процесс с наибольшим потреблением CPU
3. Запустите `firefox` в фоне и найдите его PID
4. Остановите процесс firefox с помощью `kill`

**Задание 2: Работа со службами**
1. Проверьте статус службы sshd
2. Если служба не запущена, запустите ее
3. Включите автозагрузку sshd
4. Проверьте, что служба добавлена в автозагрузку

**Задание 3: Анализ журналов**
1. Просмотрите последние 20 записей в журнале системы
2. Найдите записи об ошибках (уровень err)
3. Проверьте логи службы sshd за последний час

**Задание 4: Планирование задач**
1. Создайте crontab-задачу для ежедневного резервного копирования домашней директории в 2:00 утра
2. Создайте задачу в systemd timer для проверки свободного места на диске каждый час
3. Проверьте, что задачи созданы и активны

**Задание 5: Диагностика проблем**
1. Смоделируйте ситуацию с высокой нагрузкой на CPU (запустите `yes > /dev/null &`)
2. Найдите процесс, создающий нагрузку
3. Остановите процесс
4. Проверьте, что нагрузка упала

## Глоссарий терминов

- **Процесс:** Запущенная программа, выполняющаяся в оперативной памяти
- **PID (Process ID):** Уникальный числовой идентификатор процесса
- **PPID (Parent Process ID):** Идентификатор родительского процесса
- **Системный процесс:** Процесс, запущенный при загрузке системы
- **Демон:** Фоновый процесс, не имеющий прямого взаимодействия с пользователем
- **Состояние процесса:** Текущее состояние процесса (Running, Sleeping и т.д.)
- **Nice-значение:** Смещение приоритета процесса
- **systemd:** Система инициализации и менеджер служб
- **Unit-файл:** Файл описания ресурса для systemd
- **Служба (service):** Фоновый процесс, обеспечивающий работу системы
- **journalctl:** Утилита для просмотра системных журналов
- **cron:** Планировщик задач для периодического выполнения
- **systemd timer:** Современная альтернатива cron в systemd

## Литература

- Официальная документация ОС «Альт»: https://docs.altlinux.org/
- Руководство по systemd: https://www.freedesktop.org/wiki/Software/systemd/
- Книга "Linux System Administration" (Evi Nemeth et al.)
- Книга "The Linux Command Line" (William Shotts)
- Форум ОС «Альт»: https://forum.altlinux.org/
- Документация по cron: man 5 crontab
- Документация по systemctl: man systemctl
